import { NextResponse } from 'next/server';

export async function POST(req: Request) {
  try {
    const { topic, currentLevel } = await req.json();
    const apiKey = process.env.GEMINI_API_KEY;

    if (!apiKey) {
      return NextResponse.json({ error: 'API Key not configured' }, { status: 500 });
    }

    const prompt = `
        Create a fun and modern Korean short story for a ${currentLevel} learner about: "${topic}".
        
        Return ONLY valid JSON with this structure:
        {
          "title": "Korean Title",
          "korean": "Korean story text (5-8 sentences)",
          "theme": {
            "primary": "Hex Color (e.g. #F59E0B)",
            "secondary": "Hex Color (light version)",
            "accent": "Hex Color (dark version)",
            "background": "Hex Color (very light)",
            "text": "Hex Color (dark contrast)",
            "icon": "String (One of: Cat, Snowflake, Ghost, Bot, BookOpen, Utensils, Zap, Moon, Sun, Monitor)"
          },
          "translations": {
            "en": "English full translation",
            "th": "Thai full translation",
            "jp": "Japanese full translation",
            "de": "German full translation",
            "cn": "Chinese full translation"
          },
          "vocab": [
            { "word": "Korean Word", "match": "Conjugated form in text if needed", "meanings": { "en": "...", "th": "...", "jp": "...", "de": "...", "cn": "..." } }
          ],
          "grammar": [
            { "pattern": "Grammar Pattern", "explanations": { "en": "...", "th": "...", "jp": "...", "de": "...", "cn": "..." }, "examples": [{ "ko": "Example sentence", "en": "Eng trans" }] }
          ]
        }
      `;

    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
          responseMimeType: "application/json",
          temperature: 0.7,
          topP: 0.95,
          topK: 40,
          maxOutputTokens: 2048,
        },
        safetySettings: [
          { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
          { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
        ]
      })
    });

    const data = await response.json();

    if (!response.ok) {
      return NextResponse.json({
        error: data.error?.message || `Gemini API Error (Status ${response.status})`,
        details: data.error
      }, { status: 500 });
    }

    if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
      // Check for safety blocking specifically
      const blockReason = data.promptFeedback?.blockReason || data.candidates?.[0]?.finishReason;
      return NextResponse.json({
        error: blockReason ? `Story blocked by Gemini Safety (${blockReason})` : "No content generated by Gemini",
        raw: data
      }, { status: 500 });
    }

    let generatedText = data.candidates[0].content.parts[0].text.trim();

    // Robust JSON extraction
    try {
      // Remove markdown highlights if present
      const cleanJson = generatedText.replace(/^```json\s*/, '').replace(/^```\s*/, '').replace(/```$/, '').trim();
      const jsonStartIndex = cleanJson.indexOf('{');
      const jsonEndIndex = cleanJson.lastIndexOf('}');

      if (jsonStartIndex === -1 || jsonEndIndex === -1) {
        throw new Error("Invalid JSON structure returned");
      }

      const finalJson = cleanJson.substring(jsonStartIndex, jsonEndIndex + 1);
      return NextResponse.json(JSON.parse(finalJson));
    } catch (parseError: any) {
      console.error("JSON Parse Error:", parseError, "Original Text:", generatedText);
      return NextResponse.json({
        error: "Failed to parse AI response. Please try again.",
        raw: generatedText.substring(0, 100) + "..."
      }, { status: 500 });
    }
  } catch (error: any) {
    console.error("Generation failed:", error);
    return NextResponse.json({ error: error.message || 'Internal Server Error' }, { status: 500 });
  }
}
